diff --git a/api/routes/login.ts b/api/routes/login.ts
index 1234567..abcdefg 100644
--- a/api/routes/login.ts
+++ b/api/routes/login.ts
@@ -50,6 +50,9 @@ export default async function router(schema: Schema, config: Config) {
     }, async (req, res) => {
         try {
+            // Check if OIDC is forced and local login is restricted
+            const oidcForced = process.env.OIDC_FORCED === 'true';
+            const localOnlyAccounts = (process.env.LOCAL_ONLY_ACCOUNTS || '').split(',').map(a => a.trim()).filter(Boolean);
+            
             let profile;
 
             if (config.server.auth.key && config.server.auth.cert) {
                 const email = await provider.login(req.body.username, req.body.password);
+                
+                // If OIDC is forced, only allow configured local-only accounts or system admins
+                if (oidcForced) {
+                    const tempProfile = await config.models.Profile.from(email);
+                    const isLocalOnly = localOnlyAccounts.includes(email);
+                    
+                    if (!isLocalOnly && !tempProfile.system_admin) {
+                        throw new Err(403, null, 'Local login is disabled. Please use SSO login.');
+                    }
+                }
 
                 profile = await config.models.Profile.from(email);
             } else {
@@ -150,6 +163,13 @@ export default async function router(schema: Schema, config: Config) {
             try {
                 profile = await config.models.Profile.from(auth.email);
                 
+                // Block OIDC login for local-only accounts (configured via env var)
+                const localOnlyAccounts = (process.env.LOCAL_ONLY_ACCOUNTS || '').split(',').map(a => a.trim()).filter(Boolean);
+                const isLocalOnly = localOnlyAccounts.includes(auth.email);
+                
+                if (isLocalOnly) {
+                    console.log(`Blocking OIDC login for local-only account: ${auth.email}`);
+                    throw new Error('This account is configured for local login only. Please use /login?local=true');
+                }
+                
                 // Update group membership and last_login for existing OIDC users
                 await config.models.Profile.commit(auth.email, {
                     id: authentikUserId,
@@ -160,6 +180,13 @@ export default async function router(schema: Schema, config: Config) {
                 profile = await config.models.Profile.from(auth.email);
             } catch (err) {
                 if (err instanceof Error && err.message.includes('Item Not Found')) {
+                    // Block OIDC from creating local-only accounts
+                    const localOnlyAccounts = (process.env.LOCAL_ONLY_ACCOUNTS || '').split(',').map(a => a.trim()).filter(Boolean);
+                    if (localOnlyAccounts.includes(auth.email)) {
+                        console.log(`Blocking OIDC account creation for local-only account: ${auth.email}`);
+                        throw new Error('This account is configured for local login only. Please use /login?local=true');
+                    }
+                    
                     isNewUser = true;
                     // Auto-create user on first OIDC login using ProfileControl to respect system defaults
                     profile = await provider.profile.generate({
@@ -231,9 +260,14 @@ export default async function router(schema: Schema, config: Config) {
                 }
             }
             
-            // Check if certificate is missing, invalid, or expired
+            // Check if certificate is missing, invalid, expired, or revoked
             const hasValidCert = profile.auth && profile.auth.cert && profile.auth.cert.length > 0;
-            const needsCertificate = !hasValidCert || (hasValidCert && await isCertificateExpired(profile.auth.cert));
+            let needsCertificate = !hasValidCert || (hasValidCert && await isCertificateExpired(profile.auth.cert));
+            
+            // If certificate exists and isn't expired, test if it's revoked by TAK Server
+            if (hasValidCert && !needsCertificate && config.server.auth.key && config.server.auth.cert) {
+                needsCertificate = await isCertificateRevoked(profile.auth, config.server.webtak);
+            }
             
             // Check if we should sync attributes from Authentik
             const shouldSyncAttributes = process.env.SYNC_AUTHENTIK_ATTRIBUTES_ON_LOGIN === 'true';
@@ -553,3 +587,33 @@ async function isCertificateExpired(certPem: string): Promise<boolean> {
         return true; // Treat invalid certificates as expired
     }
 }
+
+// Helper function to check if certificate is revoked by TAK Server
+async function isCertificateRevoked(auth: { cert: string; key: string }, takServerUrl: string): Promise<boolean> {
+    try {
+        const cert = new X509Certificate(auth.cert);
+        const serialNumber = cert.serialNumber.toLowerCase();
+        
+        // Check TAK Server API for certificate status
+        const api = await TAKAPI.init(new URL(takServerUrl), {
+            cert: auth.cert,
+            key: auth.key
+        });
+        
+        // Get active certificates and check if ours has a revocationDate
+        const response = await api.axios.get('/Marti/api/certadmin/cert/active');
+        const certs = response.data?.data || [];
+        
+        const certInfo = certs.find((c: any) => c.serialNumber?.toLowerCase() === serialNumber);
+        
+        if (certInfo && certInfo.revocationDate) {
+            console.log(`Certificate ${serialNumber} is revoked (revocationDate: ${certInfo.revocationDate})`);
+            return true;
+        }
+        
+        return false;
+    } catch (err) {
+        console.warn('Certificate revocation check failed (assuming valid):', err instanceof Error ? err.message : String(err));
+        return false;
+    }
+}
