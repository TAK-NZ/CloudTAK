diff --git a/api/lib/authentik-provider.ts b/api/lib/authentik-provider.ts
index 0000000..0000000 100644
--- a/api/lib/authentik-provider.ts
+++ b/api/lib/authentik-provider.ts
@@ -3,6 +3,8 @@ import Err from '@openaddresses/batch-error';
 import Config from './config.js';
 import { Static } from '@sinclair/typebox';
 import { Agency, MachineUser, Channel } from './external.js';
+import crypto from 'crypto';
+import TAKAPI from '@tak-ps/node-tak';
 
 export default class AuthentikProvider {
     config: Config;
@@ -450,4 +452,41 @@ export default class AuthentikProvider {
             tak_group: attributes.takColor
         };
     }
+
+    async renewConnectionCertificate(
+        machineUserId: number,
+        takApi: TAKAPI
+    ): Promise<{ cert: string; key: string }> {
+        const creds = await this.auth();
+        const tempPassword = crypto.randomBytes(32).toString('base64url');
+        
+        const passwordUrl = new URL(`/api/v3/core/users/${machineUserId}/set_password/`, this.authentikUrl);
+        const passwordResponse = await fetch(passwordUrl, {
+            method: 'POST',
+            headers: {
+                'Authorization': `Bearer ${creds.token}`,
+                'Content-Type': 'application/json'
+            },
+            body: JSON.stringify({ password: tempPassword })
+        });
+        
+        if (!passwordResponse.ok) throw new Err(500, new Error(await passwordResponse.text()), 'Failed to set password');
+        
+        const userUrl = new URL(`/api/v3/core/users/${machineUserId}/`, this.authentikUrl);
+        const userResponse = await fetch(userUrl, {
+            headers: {
+                'Authorization': `Bearer ${creds.token}`,
+                'Accept': 'application/json'
+            }
+        });
+        
+        if (!userResponse.ok) throw new Err(500, new Error(await userResponse.text()), 'Failed to fetch user');
+        const userData: any = await userResponse.json();
+        
+        const enrollment = await takApi.Certificate.generate({
+            username: userData.username,
+            password: tempPassword
+        });
+        
+        return { cert: enrollment.cert, key: enrollment.key };
+    }
 }
