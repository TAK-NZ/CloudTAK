diff --git a/api/lib/authentik-provider.ts b/api/lib/authentik-provider.ts
index 0000000..0000000 100644
--- a/api/lib/authentik-provider.ts
+++ b/api/lib/authentik-provider.ts
@@ -1,7 +1,6 @@
 import fetch from './fetch.js';
 import Err from '@openaddresses/batch-error';
 import Config from './config.js';
-import { Static } from '@sinclair/typebox';
 import { Agency, MachineUser, Channel } from './external.js';
 import crypto from 'crypto';
 import TAKAPI from '@tak-ps/node-tak';
@@ -400,8 +399,8 @@ export default class AuthentikProvider {
     }
 
     async renewConnectionCertificate(
         machineUserId: number,
-        takApi: TAKAPI
+        takServerUrl: string
     ): Promise<{ cert: string; key: string }> {
         const creds = await this.auth();
         const tempPassword = crypto.randomBytes(32).toString('base64url');
@@ -428,7 +427,11 @@ export default class AuthentikProvider {
         if (!userResponse.ok) throw new Err(500, new Error(await userResponse.text()), 'Failed to fetch user');
         const userData: any = await userResponse.json();
         
-        const enrollment = await takApi.Certificate.generate({
+        // Use password auth instead of potentially revoked certificate
+        const { APIAuthPassword } = await import('@tak-ps/node-tak');
+        const takAuth = new APIAuthPassword(userData.username, tempPassword);
+        const takApi = await TAKAPI.init(new URL(takServerUrl), takAuth);
+        const enrollment = await takApi.Certificate.generate({
             username: userData.username,
             password: tempPassword
         });
diff --git a/api/routes/connection.ts b/api/routes/connection.ts
index 0000000..0000000 100644
--- a/api/routes/connection.ts
+++ b/api/routes/connection.ts
@@ -13,7 +13,6 @@ import * as Default from '../lib/limits.js';
 import { generateClientP12, generateTrustP12 } from '../lib/certificate.js';
 import { needsCertRenewal } from '../lib/cert-health.js';
 import AuthentikProvider from '../lib/authentik-provider.js';
-import { TAKAPI, APIAuthCertificate } from '@tak-ps/node-tak';
 
 export default async function router(schema: Schema, config: Config) {
     await schema.get('/connection', {
@@ -380,8 +379,7 @@ export default async function router(schema: Schema, config: Config) {
                 return res.json({ renewed: false, message: 'Certificate does not need renewal' });
             }
 
-            const takApi = await TAKAPI.init(new URL(String(config.server.api)), new APIAuthCertificate(connection.auth.cert, connection.auth.key));
-            const renewed = await config.external.renewConnectionCertificate(connection.machine_id, takApi);
+            const renewed = await config.external.renewConnectionCertificate(connection.machine_id, String(config.server.api));
 
             await config.models.Connection.commit(req.params.connectionid, {
                 auth: { ...connection.auth, cert: renewed.cert, key: renewed.key }
@@ -430,8 +428,7 @@ export default async function router(schema: Schema, config: Config) {
             }
 
             try {
-                const takApi = await TAKAPI.init(new URL(String(config.server.api)), new APIAuthCertificate(connection.auth.cert, connection.auth.key));
-                const renewed = await config.external.renewConnectionCertificate(connection.machine_id, takApi);
+                const renewed = await config.external.renewConnectionCertificate(connection.machine_id, String(config.server.api));
 
                 await config.models.Connection.commit(connection.id, {
                     auth: { ...connection.auth, cert: renewed.cert, key: renewed.key }
diff --git a/api/routes/login.ts b/api/routes/login.ts
index 0000000..0000000 100644
--- a/api/routes/login.ts
+++ b/api/routes/login.ts
@@ -231,14 +231,9 @@ export default async function router(schema: Schema, config: Config) {
                 }
             }
             
-            // Check if certificate is missing, invalid, expired, or revoked
+            // Check if certificate is missing, invalid, or expired
             const hasValidCert = profile.auth && profile.auth.cert && profile.auth.cert.length > 0;
-            let needsCertificate = !hasValidCert || (hasValidCert && await isCertificateExpired(profile.auth.cert));
-            
-            // If certificate exists and isn't expired, test if it's revoked by TAK Server
-            if (hasValidCert && !needsCertificate && config.server.auth.key && config.server.auth.cert) {
-                needsCertificate = await isCertificateRevoked(profile.auth, config.server.webtak);
-            }
+            const needsCertificate = !hasValidCert || (hasValidCert && await isCertificateExpired(profile.auth.cert));
             
             // Check if we should sync attributes from Authentik
             const shouldSyncAttributes = process.env.SYNC_AUTHENTIK_ATTRIBUTES_ON_LOGIN === 'true';
@@ -280,7 +275,7 @@ export default async function router(schema: Schema, config: Config) {
                         // Refresh profile to get updated cert
                         profile = await config.models.Profile.from(auth.email);
                         
-                        console.log(`Certificate enrolled successfully for ${auth.email}`);
+                        console.log(`Certificate ${hasValidCert ? 'renewed' : 'enrolled'} successfully for ${auth.email}`);
                     }
                 } catch (certErr) {
                     console.error('Certificate enrollment error:', certErr);
@@ -559,32 +554,3 @@ async function isCertificateExpired(certPem: string): Promise<boolean> {
     }
 }
 
-// Helper function to check if certificate is revoked by TAK Server
-async function isCertificateRevoked(auth: { cert: string; key: string }, takServerUrl: string): Promise<boolean> {
-    try {
-        const cert = new X509Certificate(auth.cert);
-        const serialNumber = cert.serialNumber.toLowerCase();
-        
-        // Check TAK Server API for certificate status
-        const api = await TAKAPI.init(new URL(takServerUrl), {
-            cert: auth.cert,
-            key: auth.key
-        });
-        
-        // Get active certificates and check if ours has a revocationDate
-        const response = await api.axios.get('/Marti/api/certadmin/cert/active');
-        const certs = response.data?.data || [];
-        
-        const certInfo = certs.find((c: any) => c.serialNumber?.toLowerCase() === serialNumber);
-        
-        if (certInfo && certInfo.revocationDate) {
-            console.log(`Certificate ${serialNumber} is revoked (revocationDate: ${certInfo.revocationDate})`);
-            return true;
-        }
-        
-        return false;
-    } catch (err) {
-        console.warn('Certificate revocation check failed (assuming valid):', err instanceof Error ? err.message : String(err));
-        return false;
-    }
-}

