diff --git a/api/lib/auth.ts b/api/lib/auth.ts
index 227e4d9fa..024747b39 100644
--- a/api/lib/auth.ts
+++ b/api/lib/auth.ts
@@ -359,3 +359,146 @@ export async function tokenParser(
     }
 }
 
+import { createPublicKey, createVerify } from 'crypto';
+import axios from 'axios';
+
+// Cache for ALB public keys (in-memory cache)
+const albPublicKeys = new Map<string, string>();
+
+// Fetch ALB public key for JWT verification
+async function getAlbPublicKey(region: string, keyId: string): Promise<string> {
+    const cacheKey = `${region}:${keyId}`;
+    
+    if (albPublicKeys.has(cacheKey)) {
+        return albPublicKeys.get(cacheKey)!;
+    }
+    
+    const url = `https://public-keys.auth.elb.${region}.amazonaws.com/${keyId}`;
+    const response = await axios.get(url, { timeout: 5000 });
+    
+    if (!response.data) {
+        throw new Error('Failed to fetch ALB public key');
+    }
+    
+    albPublicKeys.set(cacheKey, response.data);
+    return response.data;
+}
+
+// Verify JWT signature using ALB public key
+function verifyJwtSignature(token: string, publicKeyPem: string): boolean {
+    const [headerB64, payloadB64, signatureB64] = token.split('.');
+    
+    if (!headerB64 || !payloadB64 || !signatureB64) {
+        throw new Error('Invalid JWT format');
+    }
+    
+    const message = `${headerB64}.${payloadB64}`;
+    const signature = Buffer.from(signatureB64.replace(/-/g, '+').replace(/_/g, '/'), 'base64');
+    
+    const publicKey = createPublicKey(publicKeyPem);
+    const verify = createVerify('SHA256');
+    verify.update(message);
+    verify.end();
+    
+    return verify.verify(publicKey, signature);
+}
+
+// OIDC authentication parser for ALB OIDC headers with full security validation
+export async function oidcParser(req: Request): Promise<{ user: AuthUser; groups: string[] }> {
+    // 1. Check if OIDC is enabled
+    if (!process.env.ALB_OIDC_ENABLED || process.env.ALB_OIDC_ENABLED !== 'true') {
+        throw new Err(404, null, 'OIDC authentication not enabled');
+    }
+    
+    // 2. Validate OIDC data header exists
+    const oidcData = req.headers['x-amzn-oidc-data'];
+    if (!oidcData || typeof oidcData !== 'string') {
+        throw new Err(401, null, 'No OIDC data');
+    }
+    
+    // 3. Validate access token header exists (ensures request came through ALB)
+    const accessToken = req.headers['x-amzn-oidc-accesstoken'];
+    if (!accessToken) {
+        throw new Err(401, null, 'No OIDC access token - request may not have come through ALB');
+    }
+    
+    // 4. Extract and validate JWT header
+    const [headerB64] = oidcData.split('.');
+    if (!headerB64) {
+        throw new Err(401, null, 'Invalid JWT format');
+    }
+    
+    const header = JSON.parse(Buffer.from(headerB64, 'base64').toString());
+    const keyId = header.kid;
+    const alg = header.alg;
+    
+    if (!keyId) {
+        throw new Err(401, null, 'No key ID in JWT header');
+    }
+    
+    if (alg !== 'ES256') {
+        throw new Err(401, null, `Invalid JWT algorithm: ${alg}. Expected ES256`);
+    }
+    
+    // 5. Get ALB public key and verify signature
+    const region = process.env.AWS_REGION || 'us-west-2';
+    let publicKeyPem: string;
+    
+    try {
+        publicKeyPem = await getAlbPublicKey(region, keyId);
+    } catch (err) {
+        throw new Err(401, err instanceof Error ? err : new Error(String(err)), 'Failed to fetch ALB public key');
+    }
+    
+    const isValid = verifyJwtSignature(oidcData, publicKeyPem);
+    if (!isValid) {
+        throw new Err(401, null, 'Invalid JWT signature');
+    }
+    
+    // 6. Decode and validate payload
+    const payload = JSON.parse(
+        Buffer.from(oidcData.split('.')[1], 'base64').toString()
+    );
+    
+    console.log('OIDC Payload:', JSON.stringify(payload, null, 2));
+    
+    // 7. Validate token expiration
+    if (payload.exp) {
+        const now = Math.floor(Date.now() / 1000);
+        if (payload.exp < now) {
+            throw new Err(401, null, 'OIDC token expired');
+        }
+    }
+    
+    // 8. Validate issuer (if configured)
+    const expectedIssuer = process.env.AUTHENTIK_URL;
+    if (expectedIssuer && payload.iss) {
+        // Normalize URLs for comparison (remove trailing slash)
+        const normalizedExpected = expectedIssuer.replace(/\/$/, '');
+        const normalizedActual = payload.iss.replace(/\/$/, '');
+        
+        if (normalizedActual !== normalizedExpected) {
+            throw new Err(401, null, `Invalid token issuer: ${payload.iss}`);
+        }
+    }
+    
+    // 9. Validate email claim
+    if (!payload.email) {
+        throw new Err(401, null, 'No email in OIDC data');
+    }
+    
+    // 10. Extract groups from OIDC token
+    const groups = Array.isArray(payload.groups) ? payload.groups : [];
+    
+    // Default to USER access, will be upgraded based on profile
+    return {
+        user: new AuthUser(AuthUserAccess.USER, payload.email),
+        groups
+    };
+}
+
+// Helper to check if OIDC is enabled
+export function isOidcEnabled(): boolean {
+    return process.env.ALB_OIDC_ENABLED === 'true';
+}
+
